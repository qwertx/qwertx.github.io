[ { "title": "LeetCode7月题目", "url": "/posts/LeetCode7%E6%9C%88%E9%A2%98%E7%9B%AE/", "categories": "数据结构和算法, LeetCode", "tags": "DP, 并查集, 跳表, 拓扑排序, 字典树", "date": "2022-07-31 05:10:00 +0800", "snippet": "个人感觉7月的每日一题中比较重要的题目（从7.9开始）7.30 公因数计算最大组件https://leetcode.cn/problems/largest-component-size-by-common-factor/数组中每个数找到其对应的所有因数，并使用并查集进行连通，完成后进行统计并查集模板 查找的时候进行路径压缩，对每个路径上的结点，都直接挂到根结点下面 合并的时候按秩（树深度）进行合并，深度相等的时候需要将深度+1class UnionFind { public: UnionFind(int n) { parent = vector&amp;lt;int&amp;gt;(n, 0); rank = vector&amp;lt;int&amp;gt;(n, 0); for(int i = 0; i &amp;lt; n; ++i) { parent[i] = i; rank[i] = 1; } } int find(int i) { if(parent[i] == i) return i; // 路径压缩 parent[i] = find(parent[i]); return parent[i]; } void merge(int x, int y) { // 按秩合并 int p1 = find(x), p2 = find(y); if(p1 == p2) return; if(rank[p1] &amp;lt; rank[p2]) { // p1合并到p2 parent[p1] = p2; } else if(rank[p1] &amp;gt; rank[p2]) { parent[p2] = p1; } else { parent[p2] = p1; rank[p1]++; } } private: vector&amp;lt;int&amp;gt; parent; vector&amp;lt;int&amp;gt; rank;};7.26 设计跳表https://leetcode.cn/problems/design-skiplist/每一层都是一个链表，插入时会随机选择一层，并在所选层下面的所有层都插入该结点搜索时从最上层开始搜索，期望复杂度为log(n)，与红黑树接近#define MAX_LEVEL 32class Skiplist {public: Skiplist() { for(int i = 0; i &amp;lt; MAX_LEVEL; ++i) { lists[i] = new Node(); } } bool search(int target) { Node* curr = nullptr; for(int i = MAX_LEVEL - 1; i &amp;gt;= 0; --i) { curr = lists[i]; while(curr &amp;amp;&amp;amp; curr-&amp;gt;val &amp;lt; target) { curr = curr-&amp;gt;next[i]; } if(curr &amp;amp;&amp;amp; curr-&amp;gt;val == target) return true; } return false; } void add(int num) { int level = get_level(); Node* curr = nullptr; Node* tmp = new Node(); tmp-&amp;gt;val = num; for(int i = 0; i &amp;lt; level; ++i) { curr = lists[i]; while(curr-&amp;gt;next[i] &amp;amp;&amp;amp; curr-&amp;gt;next[i]-&amp;gt;val &amp;lt; num) { curr = curr-&amp;gt;next[i]; } Node* n = curr-&amp;gt;next[i]; curr-&amp;gt;next[i] = tmp; tmp-&amp;gt;next[i] = n; } } bool erase(int num) { Node* curr = nullptr, *target = nullptr; int target_lv = MAX_LEVEL - 1; for( ; target_lv &amp;gt;= 0; --target_lv) { curr = lists[target_lv]; while(curr &amp;amp;&amp;amp; curr-&amp;gt;val &amp;lt; num) { curr = curr-&amp;gt;next[target_lv]; } if(curr &amp;amp;&amp;amp; curr-&amp;gt;val == num &amp;amp;&amp;amp; curr != lists[target_lv]) { target = curr; break; } } if(!target) return false; for(int i = 0; i &amp;lt;= target_lv; ++i) { curr = lists[i]; while(curr-&amp;gt;next[i] &amp;amp;&amp;amp; curr-&amp;gt;next[i] != target) { curr = curr-&amp;gt;next[i]; } if(curr-&amp;gt;next[i] == target) { curr-&amp;gt;next[i] = target-&amp;gt;next[i]; } } delete target; return true; } int get_level() { int level = 1; while(rand() &amp;lt; RAND_MAX / 4 &amp;amp;&amp;amp; level &amp;lt; MAX_LEVEL - 1) level++; return level; } struct Node { int val = -1; Node* next[MAX_LEVEL] = {nullptr}; };private: Node* lists[MAX_LEVEL];};7.23 重建序列https://leetcode.cn/problems/ur2n8P/拓扑排序应用，序列转为图，如果下一个结点候选多于1个，那么就不唯一拓扑排序：和bfs类似，从入度为0的结点开始入队，弹出后加入下一层结点bool sequenceReconstruction(vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; sequences) { int n = nums.size(); vector&amp;lt;unordered_set&amp;lt;int&amp;gt;&amp;gt; graph(n + 1); vector&amp;lt;int&amp;gt; indegree(n + 1, 0); for(auto&amp;amp; seq: sequences) { for(int i = 1; i &amp;lt; seq.size(); ++i) { graph[seq[i-1]].insert(seq[i]); indegree[seq[i]]++; } } queue&amp;lt;int&amp;gt; q; for(int i = 1; i &amp;lt;= n; ++i) { if(indegree[i] == 0) q.push(i); } while(!q.empty()) { if(q.size() &amp;gt; 1) return false; int curr = q.front(); q.pop(); for(auto&amp;amp; i: graph[curr]) { indegree[i]--; if(indegree[i] == 0) { q.push(i); } } } return true;}7.22 设置交集大小至少为2https://leetcode.cn/problems/set-intersection-size-at-least-two/排序后贪心（从后向前）int intersectionSizeTwo(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; intervals) { sort(intervals.begin(), intervals.end(), [](vector&amp;lt;int&amp;gt;&amp;amp; a, vector&amp;lt;int&amp;gt;&amp;amp; b) { return a[0] == b[0] ? a[1] &amp;gt; b[1] : a[0] &amp;lt; b[0]; }); int n1 = intervals[intervals.size()-1][0]; int n2 = intervals[intervals.size()-1][0] + 1; // vector&amp;lt;int&amp;gt; res{n1, n2}; int res = 2; for(int i = intervals.size() - 2; i &amp;gt;= 0; --i) { if(intervals[i][1] &amp;lt; n1) { res += 2; n1 = intervals[i][0]; n2 = intervals[i][0] + 1; // res.push_back(n1); // res.push_back(n2); } else if(intervals[i][1] == n1) { res += 1; int tmp = n1; n1 = intervals[i][0]; // res.push_back(n1); n2 = tmp; } else if(intervals[i][1] &amp;lt; n2) { // 此时intervals[i][1] &amp;gt; n1并且intervals[i][0]和n1不可能相等 res += 1; n2 = n1; n1 = intervals[i][0]; // res.push_back(n1); } // cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; endl; } // for(int i: res) cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; return res;}7.19 我的日程安排表 IIhttps://leetcode.cn/problems/my-calendar-ii/线段树（见线段树专题）7.18 隔离病毒https://leetcode.cn/problems/contain-virus/BFS模拟，注意不同状态值的使用vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dirs{ {0, 1}, {1, 0}, {0, -1}, {-1, 0} };int bfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; isInfected, int&amp;amp; idx, int start_x, int start_y, int&amp;amp; m, int&amp;amp; n, unordered_set&amp;lt;int&amp;gt;&amp;amp; neighbor) { int walls = 0, tmp_x = 0, tmp_y = 0; queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; q.push(make_pair(start_x, start_y)); isInfected[start_x][start_y] = -idx; while(!q.empty()) { auto [x, y] = q.front(); q.pop(); for(int i = 0; i &amp;lt; 4; ++i) { tmp_x = x + dirs[i][0]; tmp_y = y + dirs[i][1]; if(tmp_x &amp;lt; 0 || tmp_x &amp;gt;= m || tmp_y &amp;lt; 0 || tmp_y &amp;gt;= n) continue; if(isInfected[tmp_x][tmp_y] == 1) { q.push(make_pair(tmp_x, tmp_y)); isInfected[tmp_x][tmp_y] = -idx; } else if(isInfected[tmp_x][tmp_y] == 0) { ++walls; neighbor.insert(tmp_x * n + tmp_y); } } } return walls;}int containVirus(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; isInfected) { int m = isInfected.size(), n = isInfected[0].size(); int idx = 1, total_walls = 0; // 感染区域计数和墙的数量（结果） int max_neighbor = 0, max_neighbor_i = 0; int all_infected = 1; vector&amp;lt;unordered_set&amp;lt;int&amp;gt;&amp;gt; neighbors; // 与感染区域相邻的格子 vector&amp;lt;int&amp;gt; wall_cnt; // 每个感染区域需要的墙数量 for(;;) { idx = 1; neighbors.clear(); wall_cnt.clear(); all_infected = 1; // 遍历所有的感染区域 for(int i = 0; i &amp;lt; m; ++i) { for(int j = 0; j &amp;lt; n; ++j) { if(isInfected[i][j] == 1) { unordered_set&amp;lt;int&amp;gt; neighbor; wall_cnt.push_back(bfs(isInfected, idx, i, j, m, n, neighbor)); neighbors.push_back(neighbor); ++idx; } else if(isInfected[i][j] == 0) { all_infected = 0; } } } if(idx == 1 || all_infected) break; // 找出最大的感染区，计算围墙数量 max_neighbor = neighbors[0].size(); max_neighbor_i = 0; for(int i = 1; i &amp;lt; neighbors.size(); ++i) { if(neighbors[i].size() &amp;gt; max_neighbor) { max_neighbor = neighbors[i].size(); max_neighbor_i = i; } } total_walls += wall_cnt[max_neighbor_i]; // 感染区扩散 for(int i = 0; i &amp;lt; neighbors.size(); ++i) { for(auto&amp;amp; nei: neighbors[i]) { int x = nei / n, y = nei % n; if(i != max_neighbor_i) { isInfected[x][y] = 1; } } } // 负数状态恢复为1 for(int i = 0; i &amp;lt; m; ++i) { for(int j = 0; j &amp;lt; n; ++j) { if(isInfected[i][j] == -1 - max_neighbor_i) { isInfected[i][j] = 2; } else if(isInfected[i][j] &amp;lt; 0) { isInfected[i][j] = 1; } } } } return total_walls;}7.14 前缀和后缀搜索https://leetcode.cn/problems/prefix-and-suffix-search/构建前缀和后缀2个字典树class WordFilter {public: WordFilter(vector&amp;lt;string&amp;gt;&amp;amp; words) { pre = new Trie(); post = new Trie(); for(int i = 0; i &amp;lt; words.size(); ++i) { string w = words[i]; Trie* pre_curr = pre; Trie* post_curr = post; for(int j = 0; j &amp;lt; w.size(); ++j) { pre_curr-&amp;gt;idx.insert(i); if(pre_curr-&amp;gt;children[w[j]-&#39;a&#39;]) { pre_curr = pre_curr-&amp;gt;children[w[j]-&#39;a&#39;]; } else { Trie* tmp = new Trie(); pre_curr-&amp;gt;children[w[j]-&#39;a&#39;] = tmp; pre_curr = tmp; } int k = w.size() - 1 - j; post_curr-&amp;gt;idx.insert(i); if(post_curr-&amp;gt;children[w[k]-&#39;a&#39;]) { post_curr = post_curr-&amp;gt;children[w[k]-&#39;a&#39;]; } else { Trie* tmp = new Trie(); post_curr-&amp;gt;children[w[k]-&#39;a&#39;] = tmp; post_curr = tmp; } } pre_curr-&amp;gt;idx.insert(i); post_curr-&amp;gt;idx.insert(i); pre_curr-&amp;gt;is_end = 1; post_curr-&amp;gt;is_end = 1; } } int f(string pref, string suff) { Trie* pre_curr = pre; Trie* post_curr = post; for(auto&amp;amp; c: pref) { if(!pre_curr-&amp;gt;children[c-&#39;a&#39;]) return -1; pre_curr = pre_curr-&amp;gt;children[c-&#39;a&#39;]; } for(int i = suff.size() - 1; i &amp;gt;= 0; --i) { if(!post_curr-&amp;gt;children[suff[i]-&#39;a&#39;]) return -1; post_curr = post_curr-&amp;gt;children[suff[i]-&#39;a&#39;]; } for(auto iter = pre_curr-&amp;gt;idx.rbegin(); iter != pre_curr-&amp;gt;idx.rend(); ++iter) { if(post_curr-&amp;gt;idx.find(*iter) != post_curr-&amp;gt;idx.end()) return *iter; } return -1; }private: struct Trie { int is_end = 0; Trie* children[26] = {nullptr}; set&amp;lt;int&amp;gt; idx; }; Trie* pre; Trie* post;};7.11 实现一个魔法字典https://leetcode.cn/problems/implement-magic-dictionary/字典树+DFS7.10 摘樱桃https://leetcode.cn/problems/cherry-pickup/转换为2个人同时从0,0出发到右下角的过程博弈型题目，三维dp，网格坐标+步数int dp[50][50][100];int cherryPickup(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int n = grid.size(); // memset(dp, INT_MIN, sizeof(dp)); for(int i = 0; i &amp;lt; n; ++i) { for(int j = 0; j &amp;lt; n; ++j) { for(int k = 0; k &amp;lt; 2 * n; ++k) { dp[i][j][k] = INT_MIN; } } } dp[0][0][0] = grid[0][0]; for(int s = 1; s &amp;lt; 2 * n - 1; ++s) { for(int ix = 0; ix &amp;lt; n; ++ix) { for(int jx = 0; jx &amp;lt; n; ++jx) { int iy = s - ix, jy = s - jx; if(iy &amp;lt; 0 || iy &amp;gt;= n || jy &amp;lt; 0 || jy &amp;gt;= n) continue; if(grid[ix][iy] == -1 || grid[jx][jy] == -1) continue; int reward = grid[ix][iy]; if(ix != jx) reward += grid[jx][jy]; dp[ix][jx][s] = max(dp[ix][jx][s], dp[ix][jx][s-1] + reward); // 都向下 if(ix &amp;gt; 0) dp[ix][jx][s] = max(dp[ix][jx][s], dp[ix-1][jx][s-1] + reward); // 向右， 向下 if(jx &amp;gt; 0) dp[ix][jx][s] = max(dp[ix][jx][s], dp[ix][jx-1][s-1] + reward); // 向下，向右 if(ix &amp;gt; 0 &amp;amp;&amp;amp; jx &amp;gt; 0) dp[ix][jx][s] = max(dp[ix][jx][s], dp[ix-1][jx-1][s-1] + reward); // 都向右 } } } return max(0, dp[n-1][n-1][2*n-2]);}7.9 最长的斐波那契子序列的长度https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/动态规划，使用以j和i为结尾的斐波那契子序列长度作为表格内容int lenLongestFibSubseq(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int n = arr.size(), res = 0; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(n, vector&amp;lt;int&amp;gt;(n, 0)); unordered_map&amp;lt;int, int&amp;gt; mp; for(int i = 0; i &amp;lt; n; ++i) { mp[arr[i]] = i; } for(int i = 2; i &amp;lt; arr.size(); ++i) { for(int j = i - 1; j &amp;gt; 0 &amp;amp;&amp;amp; arr[j] * 2 &amp;gt; arr[i]; --j) { int target = arr[i] - arr[j]; if(mp.find(target) != mp.end()) { int k = mp[target]; dp[j][i] = max(3, dp[k][j] + 1); } res = max(res, dp[j][i]); } } return res;}" }, { "title": "KMP", "url": "/posts/KMP/", "categories": "数据结构和算法", "tags": "KMP", "date": "2022-07-31 05:05:00 +0800", "snippet": "一直记不住的一个算法//// Created by Q Wang on 2022/4/4.//#ifndef ALGS_KMP_H#define ALGS_KMP_H#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;// 假设主串为A，索引为i，模式串为B，索引为j// 匹配失败，需要将b串后移，如何后移？// i// a b a b a b a a b// a b a b a c b// j// 当且仅当匹配成功的部分的前缀与后缀有交集时，需要移动到i前面某个位置// 否则直接将B移到i重新匹配// i// a b a b a b a a b// a b a b a c b// j// 此时，j回溯到匹配串当前位置的最长公共前后缀// next数组用于存放j在每个位置时回溯的位置// 方法：// i, j为-1// 如果A[i+1]=B[j+1]，i++, j++// 如果不等于，回溯j到next[j]，直到A[i+1]=B[j+1]// 若j=-1时都不满足，增加i，直到A[i+1]=B[j+1]// j=m-1时，输出位置// next数组的构建方法// B串与自身匹配，后缀为主串，前缀为模式串// 如果匹配，next[i]=j+1// 否则回溯j=next[j], 直到匹配成功// j i// a b c a b e e e a b c a b c// 0 0 0 1 2 0 0 0 1 2// 此时B[j+1]=B[i+1]，则next[i]=j+1(即3，此处下标从1开始)// a b c a b e e e a b c a b c// 0 0 0 1 2 0 0 0 1 2 3 4 5 3// 复杂度：// 匹配成功，主串指针前移，失败则模式串前移，二者都最多移动n次，因此为2n// 同理，构造next数组复杂度为2m，因此为O(m+n)// a为主串，b为匹配串int KMP(std::string&amp;amp; a, std::string&amp;amp; b) { int m = a.length(), n = b.length(); // 构造next数组 std::vector&amp;lt;int&amp;gt; next(n, -1); int j = -1; for(int i = 1; i &amp;lt; n; ++i) { // 单个字符无法构成前后缀，因此从第二个字符开始 while(j &amp;gt;= 0 &amp;amp;&amp;amp; b[i] != b[j+1]) j = next[j]; // 匹配失败 if(b[i] == b[j+1]) { // 匹配成功 j++; next[i] = j; } } // 正式匹配 j = -1; for(int i = -1; i &amp;lt; m - 1; ++i) { while(j &amp;gt;= 0 &amp;amp;&amp;amp; a[i+1] != b[j+1]) j = next[j]; if(a[i+1] == b[j+1]) j++; if(j == n - 1) return i + 1 - n + 1; // 匹配的位置 } return -1;}#endif //ALGS_KMP_H" }, { "title": "树状数组和线段树", "url": "/posts/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/", "categories": "数据结构和算法", "tags": "树状数组, 线段树", "date": "2022-07-31 05:00:00 +0800", "snippet": "树状数组#ifndef ALGS_TREE_ARRAY_H#define ALGS_TREE_ARRAY_H#include &amp;lt;vector&amp;gt;// 树状数组，和线段树相似// 4// / ｜// 2 空// / ｜ / ｜// 1 空 3 空// c[1] = a[1]// c[2] = a[1] + a[2]// c[3] = a[3]// c[4] = a[1] + a[2] + a[3] + a[4]// 叶子节点最后一位为1，上面一层第二位为1，...// 某元素的父节点为该节点+最后一位1（比如：6（110）的父节点为110+010=1000（8））// 更新时自下而上更新（比如1--2--4）// 求和时不断减去自身lowbit并累加class TreeArray {public: // data从下标1开始 TreeArray(std::vector&amp;lt;int&amp;gt;&amp;amp; data) { tree_ = std::vector&amp;lt;int&amp;gt;(data.size(), 0); for(int i = 1; i &amp;lt; data.size(); ++i) { int curr = i; while(curr &amp;lt; data.size()) { tree_[curr] += data[i]; curr += lowBit(curr); } } } // 第i个数加上x void modify(int i, int x) { int curr = i; while(curr &amp;lt; tree_.size()) { tree_[curr] += x; curr += lowBit(curr); } } // l-r的和，闭区间 int query(int l, int r) { return sum(r) - sum(l - 1); }private: // 找到x的二进制表示中最后一位1 int lowBit(int x) { return x &amp;amp; -x; } // 求1-i的和 int sum(int i) { int curr = i, sum = 0; while(curr &amp;gt; 0) { sum += tree_[curr]; curr -= lowBit(curr); } return sum; } std::vector&amp;lt;int&amp;gt; tree_;};#endif //ALGS_TREE_ARRAY_H线段树分为固定大小和动态开点2种方式// 一个求区间和的传统线段树，需要4N空间，注意数组idx从1开始class SegmentTree {public: void buildTree(int idx, int l, int r) { if(l == r) { tree[idx] = l; return; } int mid = (l + r) / 2; buildTree(idx * 2, l, mid); buildTree(idx * 2 + 1, mid + 1, r); tree[idx] = tree[idx*2] + tree[idx*2+1]; } // ul ur是要更新的区间，l和r为当前区间，val是要更新的值，比如区间内每个数+1 // 注意lazy标记的使用 void push_down(int idx, int l, int mid, int r) { if(l == r) return; // 向下传递标记并更新值，注意要连之前累积的值一起更新了 lazy[idx*2] += lazy[idx]; lazy[idx*2+1] += lazy[idx]; tree[idx*2] += lazy[idx] * (mid - l + 1); tree[idx*2+1] += lazy[idx] * (r - mid); // 清除当前结点的lazy lazy[idx] = 0; } void update(int ul, int ur, int l, int r, int idx, int val) { // 没有交集，画个图很容易理解 if(ur &amp;lt; l || ul &amp;gt; r) return; // 完全覆盖（当前区间完全在目标区间） if(l &amp;gt;= ul &amp;amp;&amp;amp; r &amp;lt;= ur) { tree[idx] += val * (r - l + 1); // 非叶结点要更新lazy if(r &amp;gt; l) lazy[idx] += val; return; } // 部分包含，需要递归处理 int mid = (l + r) / 2; push_down(idx, l, mid, r); // 递归 update(ul, ur, l, mid, idx * 2, val); update(ul, ur, mid + 1, r, idx * 2 + 1, val); tree[idx] = tree[idx*2] + tree[idx*2+1]; } int query(int ul, int ur, int l, int r, int idx) { if(ur &amp;lt; l || ul &amp;gt; r) return 0; if(l &amp;gt;= ul &amp;amp;&amp;amp; r &amp;lt;= ur) { return tree[idx]; } int mid = (l + r) / 2; push_down(idx, l, mid, r); return query(ul, ur, l, mid, idx * 2) + query(ul, ur, mid + 1, r, idx * 2 + 1); } void printTree(int i) { cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; tree[i] &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; lazy[i] &amp;lt;&amp;lt; endl; if(i * 2 &amp;lt; 16) { printTree(i * 2); } if(i * 2 + 1 &amp;lt; 16) { printTree(i * 2 + 1); } } int lazy[4*N] = {0}; int tree[4*N] = {0};};// 动态开点线段树，以日程表II为例class MyCalendarTwo {public: class SegmentTreeDynamic { public: struct Node { Node* left = nullptr; Node* right = nullptr; int val = 0; int lazy = 0; }; SegmentTreeDynamic() { root = new Node(); } void push_down(Node* curr) { if(!curr-&amp;gt;left) curr-&amp;gt;left = new Node(); if(!curr-&amp;gt;right) curr-&amp;gt;right = new Node(); if(curr-&amp;gt;lazy == 0) return; // 向下传递标记并更新值，由于是取最大值，无需累加区间长度 curr-&amp;gt;left-&amp;gt;lazy += curr-&amp;gt;lazy; curr-&amp;gt;right-&amp;gt;lazy += curr-&amp;gt;lazy; curr-&amp;gt;left-&amp;gt;val += curr-&amp;gt;lazy; curr-&amp;gt;right-&amp;gt;val += curr-&amp;gt;lazy; // 清除当前结点的lazy curr-&amp;gt;lazy = 0; } void update(int ul, int ur, int l, int r, Node* curr) { if(ur &amp;lt; l || ul &amp;gt; r) return; // 完全覆盖（当前区间完全在目标区间） if(l &amp;gt;= ul &amp;amp;&amp;amp; r &amp;lt;= ur) { curr-&amp;gt;val += 1; curr-&amp;gt;lazy += 1; return; } // 部分包含，需要递归处理 int mid = (l + r) &amp;gt;&amp;gt; 1; push_down(curr); // 递归 update(ul, ur, l, mid, curr-&amp;gt;left); update(ul, ur, mid + 1, r, curr-&amp;gt;right); curr-&amp;gt;val = max(curr-&amp;gt;left-&amp;gt;val, curr-&amp;gt;right-&amp;gt;val); } int query(int ul, int ur, int l, int r, Node* curr) { if(ur &amp;lt; l || ul &amp;gt; r) return 0; if(l &amp;gt;= ul &amp;amp;&amp;amp; r &amp;lt;= ur) { return curr-&amp;gt;val; } int mid = (l + r) &amp;gt;&amp;gt; 1; push_down(curr); return max(query(ul, ur, l, mid, curr-&amp;gt;left), query(ul, ur, mid + 1, r, curr-&amp;gt;right)); } Node* root; }; MyCalendarTwo() { st = new SegmentTreeDynamic(); } bool book(int start, int end) { if(st-&amp;gt;query(start, end - 1, 0, 1e9, st-&amp;gt;root) == 2) return false; st-&amp;gt;update(start, end - 1, 0, 1e9, st-&amp;gt;root); return true; } SegmentTreeDynamic* st;};" }, { "title": "My First Post", "url": "/posts/First-Post/", "categories": "Others", "tags": "misc", "date": "2022-07-26 00:00:00 +0800", "snippet": "立个Flag，坚持每周写一篇。后续会把之前整理的内容都上传一下。PS：发现一个很坑的地方：此处如果写成2个连续的大括号会导致解析出错，只有在中间加个空格vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dirs{ {0, 1}, {1, 0}, {0, -1}, {-1, 0} };" } ]
