<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>Hira's Home</title><subtitle>Hira's personal blog</subtitle> <updated>2022-08-01T00:49:08+08:00</updated> <author> <name>Q Wang</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2022 Q Wang </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>LeetCode7月题目</title><link href="/posts/LeetCode7%E6%9C%88%E9%A2%98%E7%9B%AE/" rel="alternate" type="text/html" title="LeetCode7月题目" /><published>2022-07-31T05:10:00+08:00</published> <updated>2022-07-31T05:10:00+08:00</updated> <id>/posts/LeetCode7%E6%9C%88%E9%A2%98%E7%9B%AE/</id> <content src="/posts/LeetCode7%E6%9C%88%E9%A2%98%E7%9B%AE/" /> <author> <name>Q Wang</name> </author> <category term="数据结构和算法" /> <category term="LeetCode" /> <summary> 个人感觉7月的每日一题中比较重要的题目（从7.9开始） 7.30 公因数计算最大组件 https://leetcode.cn/problems/largest-component-size-by-common-factor/ 数组中每个数找到其对应的所有因数，并使用并查集进行连通，完成后进行统计 并查集模板 查找的时候进行路径压缩，对每个路径上的结点，都直接挂到根结点下面 合并的时候按秩（树深度）进行合并，深度相等的时候需要将深度+1 class UnionFind { public: UnionFind(int n) { parent = vector&amp;lt;int&amp;gt;(n, 0); rank = vector&amp;lt;int&amp;gt;(n, 0); for(in... </summary> </entry> <entry><title>KMP</title><link href="/posts/KMP/" rel="alternate" type="text/html" title="KMP" /><published>2022-07-31T05:05:00+08:00</published> <updated>2022-07-31T05:05:00+08:00</updated> <id>/posts/KMP/</id> <content src="/posts/KMP/" /> <author> <name>Q Wang</name> </author> <category term="数据结构和算法" /> <summary> 一直记不住的一个算法 // // Created by Q Wang on 2022/4/4. // #ifndef ALGS_KMP_H #define ALGS_KMP_H #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; // 假设主串为A，索引为i，模式串为B，索引为j // 匹配失败，需要将b串后移，如何后移？ // i // a b a b a b a a b // a b a b a c b // j // 当且仅当匹配成功的部分的前缀与后缀有交集时，需要移动到i前面某个位置 // 否则直接将B移到i重新匹配 // i // a b a b a b a a b // a b a b a c b // j // 此时，j回溯到匹配串当前位置的最长公... </summary> </entry> <entry><title>树状数组和线段树</title><link href="/posts/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="alternate" type="text/html" title="树状数组和线段树" /><published>2022-07-31T05:00:00+08:00</published> <updated>2022-07-31T05:00:00+08:00</updated> <id>/posts/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/</id> <content src="/posts/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/" /> <author> <name>Q Wang</name> </author> <category term="数据结构和算法" /> <summary> 树状数组 #ifndef ALGS_TREE_ARRAY_H #define ALGS_TREE_ARRAY_H #include &amp;lt;vector&amp;gt; // 树状数组，和线段树相似 // 4 // / ｜ // 2 空 // / ｜ / ｜ // 1 空 3 空 // c[1] = a[1] // c[2] = a[1] + a[2] // c[3] = a[3] // c[4] = a[1] + a[2] + a[3] + a[4] // 叶子节点最后一位为1，上面一层第二位为1，... // 某元素的父节点为该节点+最后一位1（比如：6（110）的父节点为110+010=1000（8）） // 更新时自下而上更新（比如1--2--4） // 求和时不断减去自身lowbit并累加 class TreeAr... </summary> </entry> <entry><title>My First Post</title><link href="/posts/First-Post/" rel="alternate" type="text/html" title="My First Post" /><published>2022-07-26T00:00:00+08:00</published> <updated>2022-08-01T00:36:40+08:00</updated> <id>/posts/First-Post/</id> <content src="/posts/First-Post/" /> <author> <name>Q Wang</name> </author> <category term="Others" /> <summary> 立个Flag，坚持每周写一篇。 后续会把之前整理的内容都上传一下。 PS：发现一个很坑的地方： 此处如果写成2个连续的大括号会导致解析出错，只有在中间加个空格 vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dirs{ {0, 1}, {1, 0}, {0, -1}, {-1, 0} }; </summary> </entry> </feed>
